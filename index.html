<!-- GRK 2025-09-04: Restored MIDI functionality, removed chord detection, updated sequencer with play/pause/clear controls, made notes relative to sequencer note in play mode, modified 0/5 keys for octave shifts in sequencer play mode, added configurable tempo/steps, and updated documentation -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Relative Keyboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 flex justify-center items-center min-h-screen">
    <div class="p-6 bg-white rounded-lg shadow-lg">
        <h1 class="text-2xl font-bold text-center mb-4">Relative Keyboard</h1>
        <p class="text-center mb-2">Current Note: None</p>
        <p class="text-center mb-2">Tonic: C4</p>
        <p class="text-center mb-2">Mode: Ionian</p>
        <p class="text-center mb-2">Intervals: 6th -1, 4th -1, 3rd -1, 2nd -1, Last Note, 2nd, 3rd, 4th, 6th</p>
        <p class="text-center mb-2">Top Row Octave Offset: 0</p>
        <p class="text-center mb-2">MIDI Status: Checking...</p>
        <p class="text-center mb-2">Sequencer: Stopped (16 steps, 120 BPM)</p>
        <div class="flex justify-center mb-4">
            <select id="keypad-layout" class="p-2 border rounded">
                <option value="default">Default Keypad</option>
                <option value="alternate">Alternate Keypad (Clear)</option>
            </select>
        </div>
        <div class="flex justify-center mb-4">
            <select id="midi-select" class="p-2 border rounded hidden">
                <option value="">Select MIDI Port</option>
            </select>
        </div>
        <div class="flex justify-center mb-4">
            <select id="tone-select" class="p-2 border rounded">
                <option value="sine">Sine Wave</option>
                <option value="organ">Organ</option>
                <option value="buzz1">Buzz1</option>
                <option value="buzz2">Buzz2</option>
                <option value="ting">Ting</option>
            </select>
        </div>
        <p class="text-center mb-4">Serve over HTTPS (e.g., GitHub Pages) for MIDI. Use keypad 0–9 for notes (5 for last note or +1 octave in sequencer play mode, 0 for tonic or -1 octave in play mode, 1–4 descending, 6–9 ascending); top row 0–9 for notes relative to last keypad note; NumLock or Clear (F) for key selection or sequencer controls (F+C to record, F+D to clear); / (A) for key selection, * (B) for mode, + (C) for tone cycle or play/pause in sequencer play mode, - (D) for intervals; Enter for sequencer record toggle; Shift + 3–9 for modes; = + 1/2 for top row octave offset (+1/-1); number + F + 7/8 to set tempo/steps (e.g., 160 F 7 for 160 BPM).</p>
    </div>

    <script>
        // Initialize Web Audio context
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // Global state
        let currentKey = 0;
        let currentMode = 'ionian';
        let currentTonicDegree = 0;
        let currentNote = 60;
        const activeOscillators = new Map();
        let currentTone = 'sine';
        let midiOutput = null;
        let keySelectionMode = null; // null, 'key', 'mode', 'interval', 'octave', 'set'
        let keySelectionTimeout = null;
        let setSelectionType = null; // 'tempo' or 'steps'
        let setValue = ''; // Buffer for set number input
        const tones = ['sine', 'organ', 'buzz1', 'buzz2', 'ting'];
        let topRowOctaveOffset = 0;
        let currentKeypadLayout = 'default';
        let sequencerState = 'stopped'; // stopped, recording, playing, paused
        let sequence = [];
        let sequencerTempo = 120; // BPM
        let sequencerSteps = 16;
        let sequencerInterval = null;
        let currentSequencerIndex = 0;
        let currentSequencerNote = 60;

        // Keypad layout mappings
        const keyMappings = {
            default: {
                Numpad0: { action: 'note', degree: 0, buttonKey: 'numpad0', isNumpad: true },
                Numpad1: { action: 'note', degree: -5, buttonKey: '1', isNumpad: true },
                Numpad2: { action: 'note', degree: -3, buttonKey: '2', isNumpad: true },
                Numpad3: { action: 'note', degree: -2, buttonKey: '3', isNumpad: true },
                Numpad4: { action: 'note', degree: -1, buttonKey: '4', isNumpad: true },
                Numpad5: { action: 'note', degree: 0, buttonKey: '5', isNumpad: true },
                Numpad6: { action: 'note', degree: 1, buttonKey: '6', isNumpad: true },
                Numpad7: { action: 'note', degree: 2, buttonKey: '7', isNumpad: true },
                Numpad8: { action: 'note', degree: 3, buttonKey: '8', isNumpad: true },
                Numpad9: { action: 'note', degree: 5, buttonKey: '9', isNumpad: true },
                Digit0: { action: 'note', degree: 0, buttonKey: 'digit0', isNumpad: false },
                Digit1: { action: 'note', degree: -5, buttonKey: 'digit1', isNumpad: false },
                Digit2: { action: 'note', degree: -3, buttonKey: 'digit2', isNumpad: false },
                Digit3: { action: 'note', degree: -2, buttonKey: 'digit3', isNumpad: false },
                Digit4: { action: 'note', degree: -1, buttonKey: 'digit4', isNumpad: false },
                Digit5: { action: 'note', degree: 0, buttonKey: 'digit5', isNumpad: false },
                Digit6: { action: 'note', degree: 1, buttonKey: 'digit6', isNumpad: false },
                Digit7: { action: 'note', degree: 2, buttonKey: 'digit7', isNumpad: false },
                Digit8: { action: 'note', degree: 3, buttonKey: 'digit8', isNumpad: false },
                Digit9: { action: 'note', degree: 5, buttonKey: 'digit9', isNumpad: false },
                NumLock: { action: 'keySelection' },
                NumpadDivide: { action: 'keySelection' }, // / maps to A
                NumpadMultiply: { action: 'modeSelection' }, // * maps to B
                NumpadAdd: { action: 'sequencerPlayPause' }, // + maps to C
                NumpadSubtract: { action: 'intervalSelection' }, // - maps to D
                NumpadEnter: { action: 'sequencerRecordToggle' }, // Enter for sequencer
                '0': { action: 'note', degree: 0, buttonKey: 'numpad0', isNumpad: true },
                '1': { action: 'note', degree: -5, buttonKey: '1', isNumpad: true },
                '2': { action: 'note', degree: -3, buttonKey: '2', isNumpad: true },
                '3': { action: 'note', degree: -2, buttonKey: '3', isNumpad: true },
                '4': { action: 'note', degree: -1, buttonKey: '4', isNumpad: true },
                '5': { action: 'note', degree: 0, buttonKey: '5', isNumpad: true },
                '6': { action: 'note', degree: 1, buttonKey: '6', isNumpad: true },
                '7': { action: 'note', degree: 2, buttonKey: '7', isNumpad: true },
                '8': { action: 'note', degree: 3, buttonKey: '8', isNumpad: true },
                '9': { action: 'note', degree: 5, buttonKey: '9', isNumpad: true },
                Slash: { action: 'keySelection' }, // / (alternate for A)
                Asterisk: { action: 'modeSelection' }, // * (alternate for B)
                Equal: { action: 'octaveSelection' }, // = for octave offset
                Minus: { action: 'intervalSelection' }, // - (alternate for D)
                Plus: { action: 'sequencerPlayPause' } // + (alternate for C)
            },
            alternate: {
                Numpad0: { action: 'note', degree: 0, buttonKey: 'numpad0', isNumpad: true },
                Numpad1: { action: 'note', degree: -5, buttonKey: '1', isNumpad: true },
                Numpad2: { action: 'note', degree: -3, buttonKey: '2', isNumpad: true },
                Numpad3: { action: 'note', degree: -2, buttonKey: '3', isNumpad: true },
                Numpad4: { action: 'note', degree: -1, buttonKey: '4', isNumpad: true },
                Numpad5: { action: 'note', degree: 0, buttonKey: '5', isNumpad: true },
                Numpad6: { action: 'note', degree: 1, buttonKey: '6', isNumpad: true },
                Numpad7: { action: 'note', degree: 2, buttonKey: '7', isNumpad: true },
                Numpad8: { action: 'note', degree: 3, buttonKey: '8', isNumpad: true },
                Numpad9: { action: 'note', degree: 5, buttonKey: '9', isNumpad: true },
                Digit0: { action: 'note', degree: 0, buttonKey: 'digit0', isNumpad: false },
                Digit1: { action: 'note', degree: -5, buttonKey: 'digit1', isNumpad: false },
                Digit2: { action: 'note', degree: -3, buttonKey: 'digit2', isNumpad: false },
                Digit3: { action: 'note', degree: -2, buttonKey: 'digit3', isNumpad: false },
                Digit4: { action: 'note', degree: -1, buttonKey: 'digit4', isNumpad: false },
                Digit5: { action: 'note', degree: 0, buttonKey: 'digit5', isNumpad: false },
                Digit6: { action: 'note', degree: 1, buttonKey: 'digit6', isNumpad: false },
                Digit7: { action: 'note', degree: 2, buttonKey: 'digit7', isNumpad: false },
                Digit8: { action: 'note', degree: 3, buttonKey: 'digit8', isNumpad: false },
                Digit9: { action: 'note', degree: 5, buttonKey: 'digit9', isNumpad: false },
                Clear: { action: 'keySelection' }, // Alternate for NumLock
                NumpadDivide: { action: 'keySelection' },
                NumpadMultiply: { action: 'modeSelection' },
                NumpadAdd: { action: 'sequencerPlayPause' },
                NumpadSubtract: { action: 'intervalSelection' },
                NumpadEnter: { action: 'sequencerRecordToggle' },
                '0': { action: 'note', degree: 0, buttonKey: 'numpad0', isNumpad: true },
                '1': { action: 'note', degree: -5, buttonKey: '1', isNumpad: true },
                '2': { action: 'note', degree: -3, buttonKey: '2', isNumpad: true },
                '3': { action: 'note', degree: -2, buttonKey: '3', isNumpad: true },
                '4': { action: 'note', degree: -1, buttonKey: '4', isNumpad: true },
                '5': { action: 'note', degree: 0, buttonKey: '5', isNumpad: true },
                '6': { action: 'note', degree: 1, buttonKey: '6', isNumpad: true },
                '7': { action: 'note', degree: 2, buttonKey: '7', isNumpad: true },
                '8': { action: 'note', degree: 3, buttonKey: '8', isNumpad: true },
                '9': { action: 'note', degree: 5, buttonKey: '9', isNumpad: true },
                Slash: { action: 'keySelection' },
                Asterisk: { action: 'modeSelection' },
                Equal: { action: 'octaveSelection' },
                Minus: { action: 'intervalSelection' },
                Plus: { action: 'sequencerPlayPause' }
            }
        };

        // Modes
        const modes = {
            ionian: [0, 2, 4, 5, 7, 9, 11],
            dorian: [0, 2, 3, 5, 7, 9, 10],
            phrygian: [0, 1, 3, 5, 7, 8, 10],
            lydian: [0, 2, 4, 6, 7, 9, 11],
            mixolydian: [0, 2, 4, 5, 7, 9, 10],
            aeolian: [0, 2, 3, 5, 7, 8, 10],
            locrian: [0, 1, 3, 5, 6, 8, 10]
        };

        // Mode key map for Shift + top-row
        const modeKeyMap = {
            '#': 'ionian',
            '$': 'dorian',
            '^': 'phrygian',
            '%': 'lydian',
            '&': 'mixolydian',
            '*': 'aeolian',
            '(': 'locrian'
        };

        // Selection maps
        const keySelectionMap = { '1': 0, '2': 2, '3': 4, '4': 5, '5': 7, '6': 9, '7': 11 };
        const modeSelectionMap = { '1': 'ionian', '2': 'dorian', '3': 'phrygian', '4': 'lydian', '5': 'mixolydian', '6': 'aeolian', '7': 'locrian' };
        const intervalSelectionMap = { '0': 'random', '1': 'original', '5': 'withFifth' };
        const octaveSelectionMap = { '1': 1, '2': -1 };
        const sequencerControlMap = { 'KeyC': 'startRecording', 'KeyD': 'clearSequence' };

        // Initialize MIDI
        function initMidi() {
            if (navigator.requestMIDIAccess) {
                navigator.requestMIDIAccess().then(
                    (midiAccess) => {
                        const outputs = Array.from(midiAccess.outputs.values());
                        if (outputs.length === 0) {
                            document.querySelector('p.text-center.mb-2:nth-child(6)').textContent = 'MIDI Status: No devices found. Connect a MIDI device or enable IAC Driver.';
                        } else if (outputs.length === 1) {
                            midiOutput = outputs[0];
                            document.querySelector('p.text-center.mb-2:nth-child(6)').textContent = `MIDI Status: Connected to ${midiOutput.name}`;
                        } else {
                            const select = document.getElementById('midi-select');
                            select.innerHTML = '<option value="">Select MIDI Port</option>';
                            outputs.forEach((output, index) => {
                                const option = document.createElement('option');
                                option.value = index;
                                option.textContent = output.name;
                                select.appendChild(option);
                            });
                            select.classList.remove('hidden');
                            document.querySelector('p.text-center.mb-2:nth-child(6)').textContent = 'MIDI Status: Select a port';
                            select.addEventListener('change', (event) => {
                                const index = parseInt(event.target.value);
                                if (index >= 0) {
                                    midiOutput = outputs[index];
                                    document.querySelector('p.text-center.mb-2:nth-child(6)').textContent = `MIDI Status: Connected to ${midiOutput.name}`;
                                }
                            });
                        }
                    },
                    (err) => {
                        const message = `MIDI Status: Permissions blocked. Serve over HTTPS and enable MIDI in Chrome settings (chrome://settings/content/midiDevices). Error: ${err.message}`;
                        document.querySelector('p.text-center.mb-2:nth-child(6)').textContent = message;
                        console.error(`MIDI Access Error: ${err.message}`);
                    }
                );
            } else {
                document.querySelector('p.text-center.mb-2:nth-child(6)').textContent = 'MIDI Status: Web MIDI not supported. Use Chrome and serve over HTTPS.';
            }
        }

        // Convert MIDI note to frequency
        function midiToFreq(midiNote) {
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }

        // Convert MIDI note to note name
        function midiToNoteName(midiNote) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const note = noteNames[midiNote % 12];
            const octave = Math.floor(midiNote / 12) - 1;
            return `${note}${octave}`;
        }

        // Update displays
        function updateTonicDisplay() {
            const tonicMidiNote = 60 + currentKey;
            document.querySelector('p.text-center.mb-2:nth-child(2)').textContent = `Tonic: ${midiToNoteName(tonicMidiNote)}`;
        }

        function updateModeDisplay() {
            document.querySelector('p.text-center.mb-2:nth-child(3)').textContent = `Mode: ${currentMode.charAt(0).toUpperCase() + currentMode.slice(1)}`;
        }

        function updateIntervalsDisplay() {
            const degrees = ['1', '2', '3', '4', '5', '6', '7', '8', '9'].map(key => keyMappings[currentKeypadLayout][`Numpad${key}`].degree);
            const intervalLabels = degrees.map((degree, i) => {
                if (sequencerState === 'playing' && i === 0) return 'Octave -1';
                if (sequencerState === 'playing' && i === 4) return 'Octave +1';
                if (degree === 0 && i !== 4) return 'Tonic';
                const modeIntervals = modes[currentMode];
                const degreeIndex = degree % 7;
                const normalizedDegreeIndex = degreeIndex >= 0 ? degreeIndex : degreeIndex + 7;
                const interval = modeIntervals[normalizedDegreeIndex];
                const octave = Math.floor(degree / 7);
                const intervalNames = ['Tonic', '2nd', '3rd', '4th', '5th', '6th', '7th'];
                return `${intervalNames[normalizedDegreeIndex]}${octave < 0 ? ' -1' : ''}`;
            });
            document.querySelector('p.text-center.mb-2:nth-child(4)').textContent = `Intervals: ${intervalLabels.join(', ')}`;
        }

        function updateOctaveOffsetDisplay() {
            document.querySelector('p.text-center.mb-2:nth-child(5)').textContent = `Top Row Octave Offset: ${topRowOctaveOffset}`;
        }

        function updateSequencerDisplay() {
            document.querySelector('p.text-center.mb-2:nth-child(7)').textContent = `Sequencer: ${sequencerState.charAt(0).toUpperCase() + sequencerState.slice(1)} (${sequencerSteps} steps, ${sequencerTempo} BPM)`;
        }

        // Generate random intervals
        function generateRandomIntervals() {
            const modeIntervals = modes[currentMode];
            const availableDegrees = [0, 1, 2, 3, 4, 5, 6];
            const selectedDegrees = [];
            while (selectedDegrees.length < 4) {
                const index = Math.floor(Math.random() * availableDegrees.length);
                selectedDegrees.push(availableDegrees.splice(index, 1)[0]);
            }
            selectedDegrees.sort((a, b) => a - b);
            const descendingDegrees = selectedDegrees.map(d => -d - 1).sort((a, b) => b - a);
            return [
                sequencerState === 'playing' ? -12 : 0, // 0 key: octave down in play mode
                descendingDegrees[0],
                descendingDegrees[1],
                descendingDegrees[2],
                sequencerState === 'playing' ? 12 : -1, // 5 key: octave up in play mode
                selectedDegrees[0],
                selectedDegrees[1],
                selectedDegrees[2],
                selectedDegrees[3]
            ];
        }

        // Set intervals
        function setIntervals(type) {
            let newDegrees;
            if (type === 'random') {
                newDegrees = generateRandomIntervals();
            } else if (type === 'withFifth') {
                newDegrees = sequencerState === 'playing' ?
                    [-12, -4, -3, -2, 12, 0, 1, 2, 3, 4] :
                    [0, -4, -3, -2, -1, 0, 1, 2, 3, 4];
            } else {
                newDegrees = sequencerState === 'playing' ?
                    [-12, -5, -3, -2, 12, 0, 1, 2, 3, 5] :
                    [0, -5, -3, -2, -1, 0, 1, 2, 3, 5];
            }
            ['Numpad0', 'Numpad1', 'Numpad2', 'Numpad3', 'Numpad4', 'Numpad5', 'Numpad6', 'Numpad7', 'Numpad8', 'Numpad9',
             '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
             'Digit0', 'Digit1', 'Digit2', 'Digit3', 'Digit4', 'Digit5', 'Digit6', 'Digit7', 'Digit8', 'Digit9'
            ].forEach((key, i) => {
                if (keyMappings[currentKeypadLayout][key]) {
                    keyMappings[currentKeypadLayout][key].degree = newDegrees[i % 10];
                }
            });
            updateIntervalsDisplay();
            activeOscillators.forEach((_, key) => stopNote(key));
        }

        // Set octave offset
        function setOctaveOffset(offset) {
            topRowOctaveOffset = offset;
            updateOctaveOffsetDisplay();
            activeOscillators.forEach((_, key) => stopNote(key));
        }

        // Set sequencer tempo or steps
        function setSequencerConfig(type, value) {
            if (type === 'tempo') {
                sequencerTempo = Math.max(60, Math.min(240, parseInt(value) || 120));
                console.log(`Set tempo to ${sequencerTempo} BPM`);
            } else if (type === 'steps') {
                sequencerSteps = Math.max(4, Math.min(64, parseInt(value) || 16));
                sequence = sequence.slice(0, sequencerSteps);
                console.log(`Set steps to ${sequencerSteps}`);
            }
            if (sequencerState === 'playing') {
                stopSequencer();
                startSequencer();
            }
            updateSequencerDisplay();
        }

        // Cycle tones
        function cycleTone() {
            const currentIndex = tones.indexOf(currentTone);
            currentTone = tones[(currentIndex + 1) % tones.length];
            document.getElementById('tone-select').value = currentTone;
            activeOscillators.forEach((_, key) => stopNote(key));
            console.log(`Cycled to tone: ${currentTone}`);
        }

        // Sequencer functions
        function startSequencer() {
            if (sequence.length === 0) return;
            sequencerState = 'playing';
            currentSequencerIndex = 0;
            const intervalMs = 60000 / sequencerTempo / 4; // 16th notes
            sequencerInterval = setInterval(() => {
                if (sequencerState !== 'playing') return;
                const note = sequence[currentSequencerIndex % sequence.length];
                currentSequencerNote = note.midiNote;
                stopNote('sequencer');
                startNote(0, 'sequencer', false, true, currentSequencerNote);
                currentSequencerIndex = (currentSequencerIndex + 1) % sequence.length;
            }, intervalMs);
            updateSequencerDisplay();
            setIntervals('original');
            console.log('Sequencer started');
        }

        function stopSequencer() {
            if (sequencerInterval) {
                clearInterval(sequencerInterval);
                sequencerInterval = null;
            }
            sequencerState = 'stopped';
            stopNote('sequencer');
            updateSequencerDisplay();
            setIntervals('original');
            console.log('Sequencer stopped');
        }

        function pauseSequencer() {
            sequencerState = 'paused';
            stopNote('sequencer');
            updateSequencerDisplay();
            console.log('Sequencer paused');
        }

        function toggleSequencerRecord() {
            if (sequencerState === 'recording') {
                sequencerState = 'stopped';
                updateSequencerDisplay();
                console.log('Recording stopped');
            } else {
                sequencerState = 'recording';
                sequence = [];
                updateSequencerDisplay();
                console.log('Recording started');
            }
            setIntervals('original');
        }

        function startRecording() {
            sequencerState = 'recording';
            sequence = [];
            updateSequencerDisplay();
            setIntervals('original');
            console.log('Recording started (overwrite)');
        }

        function clearSequence() {
            sequence = [];
            if (sequencerState === 'playing' || sequencerState === 'paused') {
                stopSequencer();
            }
            updateSequencerDisplay();
            console.log('Sequence cleared');
        }

        // Start note
        function startNote(degree, buttonKey = null, isTonic = false, isNumpad = true, sequencerNote = null) {
            const key = buttonKey || (isNumpad ? 'numpad0' : 'digit0');
            if (activeOscillators.has(key)) return;

            if (isTonic) currentTonicDegree = 0;

            let midiNote;
            if (sequencerState === 'playing' && isNumpad) {
                midiNote = sequencerNote || currentSequencerNote;
                if (!isTonic && degree !== -12 && degree !== 12) { // -12 for Numpad0, 12 for Numpad5 in play mode
                    const modeIntervals = modes[currentMode];
                    const degreeIndex = degree % 7;
                    const normalizedDegreeIndex = degreeIndex >= 0 ? degreeIndex : degreeIndex + 7;
                    const octaveOffset = Math.floor(degree / 7) * 12;
                    const interval = modeIntervals[normalizedDegreeIndex];
                    midiNote += interval + octaveOffset;
                } else {
                    midiNote += degree; // -12 for octave down, 12 for octave up
                }
            } else if (isNumpad) {
                midiNote = 60 + currentKey;
                if (!isTonic) {
                    const modeIntervals = modes[currentMode];
                    const degreeIndex = (currentTonicDegree + degree) % 7;
                    const normalizedDegreeIndex = degreeIndex >= 0 ? degreeIndex : degreeIndex + 7;
                    const octaveOffset = Math.floor((currentTonicDegree + degree) / 7) * 12;
                    const interval = modeIntervals[normalizedDegreeIndex];
                    midiNote = 60 + currentKey + interval + octaveOffset;
                }
            } else {
                midiNote = currentNote + topRowOctaveOffset * 12;
                if (!isTonic) {
                    const modeIntervals = modes[currentMode];
                    const degreeIndex = degree % 7;
                    const normalizedDegreeIndex = degreeIndex >= 0 ? degreeIndex : degreeIndex + 7;
                    const octaveOffset = Math.floor(degree / 7) * 12;
                    const interval = modeIntervals[normalizedDegreeIndex];
                    midiNote += interval + octaveOffset;
                }
            }

            // Clamp MIDI note
            if (midiNote < 24 || midiNote > 108) {
                midiNote = Math.max(24, Math.min(108, midiNote));
                console.log(`Clamped MIDI note to ${midiNote}`);
                return;
            }

            // Update currentNote for numpad
            if (isNumpad && !sequencerNote) currentNote = midiNote;

            // Send MIDI Note On
            if (midiOutput) {
                try {
                    midiOutput.send([0x90, midiNote, 100]);
                } catch (e) {
                    console.error(`MIDI Note On error: ${e.message}`);
                }
            }

            // Web Audio
            const frequency = midiToFreq(midiNote);
            const now = audioCtx.currentTime;
            let oscillator, gainNode, oscillators;
            if (currentTone === 'sine') {
                oscillator = audioCtx.createOscillator();
                gainNode = audioCtx.createGain();
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(frequency, now);
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.3, now + 0.005);
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();
                activeOscillators.set(key, { oscillator, gainNode, midiNote });
            } else if (currentTone === 'organ') {
                oscillators = [];
                gainNode = audioCtx.createGain();
                [1, 2, 3].forEach(harmonic => {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(frequency * harmonic, now);
                    osc.connect(gainNode);
                    oscillators.push(osc);
                });
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.2, now + 0.005);
                gainNode.connect(audioCtx.destination);
                oscillators.forEach(osc => osc.start());
                activeOscillators.set(key, { oscillators, gainNode, midiNote });
            } else if (currentTone === 'buzz1') {
                oscillator = audioCtx.createOscillator();
                gainNode = audioCtx.createGain();
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(frequency, now);
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.3, now + 0.005);
                gainNode.gain.exponentialRampToValueAtTime(0.1, now + 0.5);
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();
                activeOscillators.set(key, { oscillator, gainNode, midiNote });
            } else if (currentTone === 'buzz2') {
                oscillator = audioCtx.createOscillator();
                gainNode = audioCtx.createGain();
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(frequency, now);
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.3, now + 0.005);
                gainNode.gain.exponentialRampToValueAtTime(0.05, now + 0.3);
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();
                activeOscillators.set(key, { oscillator, gainNode, midiNote });
            } else if (currentTone === 'ting') {
                oscillator = audioCtx.createOscillator();
                gainNode = audioCtx.createGain();
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(frequency, now);
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.3, now + 0.005);
                gainNode.gain.exponentialRampToValueAtTime(0.05, now + 0.3);
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.start();
                activeOscillators.set(key, { oscillator, gainNode, midiNote });
            }

            document.querySelector('p.text-center.mb-2:nth-child(1)').textContent = `Current Note: ${midiToNoteName(midiNote)}`;

            // Record note if in recording mode
            if (sequencerState === 'recording' && isNumpad && !sequencerNote) {
                if (sequence.length < sequencerSteps) {
                    sequence.push({ midiNote, timestamp: Date.now() });
                    console.log(`Recorded note: ${midiNote}`);
                } else {
                    console.log('Sequence full');
                }
            }

            return { degree, midiNote };
        }

        // Stop note
        function stopNote(key) {
            const noteData = activeOscillators.get(key) || {};
            const { oscillator, oscillators, gainNode, midiNote } = noteData;
            if (gainNode) {
                const now = audioCtx.currentTime;
                gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                gainNode.gain.linearRampToValueAtTime(0.001, now + 0.005);
                if (oscillator) {
                    oscillator.stop(now + 0.005);
                } else if (oscillators) {
                    oscillators.forEach(osc => osc.stop(now + 0.005));
                }
                if (midiOutput && midiNote) {
                    try {
                        midiOutput.send([0x80, midiNote, 0]);
                    } catch (e) {
                        console.error(`MIDI Note Off error: ${e.message}`);
                    }
                }
                activeOscillators.delete(key);
                if (midiNote && key !== 'sequencer') {
                    document.querySelector('p.text-center.mb-2:nth-child(1)').textContent = `Current Note: ${midiToNoteName(midiNote)}`;
                }
            }
        }

        // Update tonic
        function updateTonic(degree, midiNote) {
            if (midiNote <= 24 || midiNote >= 108) return;
            currentTonicDegree += degree;
        }

        // Change mode
        function changeMode(mode) {
            currentMode = mode;
            currentTonicDegree = 0;
            currentNote = 60 + currentKey;
            document.querySelector('p.text-center.mb-2:nth-child(1)').textContent = `Current Note: None`;
            updateModeDisplay();
            updateTonicDisplay();
            updateIntervalsDisplay();
            activeOscillators.forEach((_, key) => stopNote(key));
        }

        // Change key
        function changeKey(keyOffset) {
            currentKey = keyOffset;
            currentTonicDegree = 0;
            currentNote = 60 + currentKey;
            document.querySelector('p.text-center.mb-2:nth-child(1)').textContent = `Current Note: None`;
            updateTonicDisplay();
            updateModeDisplay();
            updateIntervalsDisplay();
            activeOscillators.forEach((_, key) => stopNote(key));
        }

        // Initialize MIDI and displays
        initMidi();
        updateTonicDisplay();
        updateModeDisplay();
        updateIntervalsDisplay();
        updateOctaveOffsetDisplay();
        updateSequencerDisplay();

        // Handle keypad layout selection
        document.getElementById('keypad-layout').addEventListener('change', (event) => {
            currentKeypadLayout = event.target.value;
            updateIntervalsDisplay();
            activeOscillators.forEach((_, key) => stopNote(key));
            console.log(`Keypad layout changed to: ${currentKeypadLayout}`);
        });

        // Handle tone selection
        document.getElementById('tone-select').addEventListener('change', (event) => {
            currentTone = event.target.value;
            activeOscillators.forEach((_, key) => stopNote(key));
        });

        // Keyboard input handling
        document.addEventListener('keydown', (event) => {
            const key = event.key;
            const code = event.code;
            const shift = event.shiftKey;

            console.log(`Keydown: key=${key}, code=${code}, shift=${shift}`);

            // Handle set mode (number + F + 7/8)
            if (keySelectionMode === 'set') {
                if (setSelectionType) {
                    if (code === 'Digit7' || code === 'Digit8') {
                        const type = code === 'Digit7' ? 'tempo' : 'steps';
                        setSequencerConfig(type, setValue);
                        setValue = '';
                        setSelectionType = null;
                        keySelectionMode = null;
                        clearTimeout(keySelectionTimeout);
                        console.log(`Set ${type} with value: ${setValue}`);
                    } else if (/\d/.test(key)) {
                        setValue += key;
                        console.log(`Set value buffer: ${setValue}`);
                    }
                    return;
                } else if (code === 'Digit7' || code === 'Digit8') {
                    setSelectionType = code === 'Digit7' ? 'tempo' : 'steps';
                    console.log(`Entered set mode for ${setSelectionType}`);
                    return;
                }
            }

            // Handle selection modes
            if (keySelectionMode) {
                if (keySelectionMode === 'key' && key in keySelectionMap) {
                    changeKey(keySelectionMap[key]);
                    console.log(`Selected key: offset=${keySelectionMap[key]}`);
                    keySelectionMode = null;
                    clearTimeout(keySelectionTimeout);
                } else if (keySelectionMode === 'mode' && key in modeSelectionMap) {
                    changeMode(modeSelectionMap[key]);
                    console.log(`Selected mode: ${modeSelectionMap[key]}`);
                    keySelectionMode = null;
                    clearTimeout(keySelectionTimeout);
                } else if (keySelectionMode === 'interval' && key in intervalSelectionMap) {
                    setIntervals(intervalSelectionMap[key]);
                    console.log(`Selected intervals: ${intervalSelectionMap[key]}`);
                    keySelectionMode = null;
                    clearTimeout(keySelectionTimeout);
                } else if (keySelectionMode === 'octave' && key in octaveSelectionMap) {
                    setOctaveOffset(octaveSelectionMap[key]);
                    console.log(`Selected octave offset: ${octaveSelectionMap[key]}`);
                    keySelectionMode = null;
                    clearTimeout(keySelectionTimeout);
                } else if (keySelectionMode === 'sequencer' && code in sequencerControlMap) {
                    if (sequencerControlMap[code] === 'startRecording') {
                        startRecording();
                    } else if (sequencerControlMap[code] === 'clearSequence') {
                        clearSequence();
                    }
                    keySelectionMode = null;
                    clearTimeout(keySelectionTimeout);
                } else if (/\d/.test(key)) {
                    setValue += key;
                    console.log(`Set value buffer: ${setValue}`);
                }
                return;
            }

            const mapping = keyMappings[currentKeypadLayout][code];
            if (!shift && mapping) {
                console.log(`Mapped action: ${mapping.action}, code=${code}`);
                if (mapping.action === 'note') {
                    const degree = sequencerState === 'playing' && (code === 'Numpad0' || code === '0') ? -12 :
                                   sequencerState === 'playing' && (code === 'Numpad5' || code === '5') ? 12 :
                                   mapping.degree;
                    const result = startNote(degree, mapping.buttonKey, code === 'Numpad0' || code === '0' || code === 'Digit0', mapping.isNumpad);
                    if (result && (code !== 'Numpad0' && code !== '0' && code !== 'Digit0')) {
                        updateTonic(mapping.degree, result.midiNote);
                    }
                } else if (mapping.action === 'keySelection') {
                    keySelectionMode = 'key';
                    setValue = '';
                    keySelectionTimeout = setTimeout(() => keySelectionMode = null, 2000);
                    console.log('Entered key selection mode');
                } else if (mapping.action === 'modeSelection') {
                    keySelectionMode = 'mode';
                    keySelectionTimeout = setTimeout(() => keySelectionMode = null, 2000);
                    console.log('Entered mode selection mode');
                } else if (mapping.action === 'sequencerPlayPause') {
                    if (sequencerState === 'playing') {
                        pauseSequencer();
                    } else if (sequencerState === 'paused') {
                        startSequencer();
                    } else if (sequence.length > 0) {
                        startSequencer();
                    }
                } else if (mapping.action === 'intervalSelection') {
                    keySelectionMode = 'interval';
                    keySelectionTimeout = setTimeout(() => keySelectionMode = null, 2000);
                    console.log('Entered interval selection mode');
                } else if (mapping.action === 'octaveSelection') {
                    keySelectionMode = 'octave';
                    keySelectionTimeout = setTimeout(() => keySelectionMode = null, 2000);
                    console.log('Entered octave selection mode');
                } else if (mapping.action === 'sequencerRecordToggle') {
                    toggleSequencerRecord();
                }
            } else if (shift && modeKeyMap[key]) {
                console.log(`Mode key matched: key=${key}, mode=${modeKeyMap[key]}`);
                changeMode(modeKeyMap[key]);
            } else if (/\d/.test(key) && !keySelectionMode) {
                setValue += key;
                keySelectionMode = 'set';
                keySelectionTimeout = setTimeout(() => {
                    setValue = '';
                    keySelectionMode = null;
                }, 2000);
                console.log(`Started set mode with value: ${setValue}`);
            }
        });

        document.addEventListener('keyup', (event) => {
            const key = event.key;
            const code = event.code;

            console.log(`Keyup: key=${key}, code=${code}`);

            const mapping = keyMappings[currentKeypadLayout][code];
            if (mapping && mapping.action === 'note') {
                console.log(`Stopping note for code=${code}, buttonKey=${mapping.buttonKey}`);
                stopNote(mapping.buttonKey);
            }
        });
    </script>
</body>
</html>
